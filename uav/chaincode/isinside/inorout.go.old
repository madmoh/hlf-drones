package main

import (
	"gonum.org/v1/gonum/mat"
	"gonum.org/v1/gonum/spatial/kdtree"
	"gonum.org/v1/gonum/spatial/r3"
)

// TODO: Improve with go-eqsue practices (file, func, var naming style, err != nil...)

// TODO: Maybe it's possible to add a requirement (e.g., Nodes.rows = Facets.columns)
type TriangleMesh struct {
	Nodes  mat.Dense
	Facets mat.Dense
}

func GetTriangleIncenter(points *mat.Dense) mat.Dense {
	A := mat.NewDense(1, 3, points.RawRowView(0))
	B := mat.NewDense(1, 3, points.RawRowView(1))
	C := mat.NewDense(1, 3, points.RawRowView(2))
	var B_C mat.Dense
	var C_A mat.Dense
	var A_B mat.Dense
	B_C.Sub(B, C)
	C_A.Sub(C, A)
	A_B.Sub(A, B)
	a := B_C.Norm(2) // TODO: Fix, should be r3.Norm
	b := C_A.Norm(2) // TODO: Fix, should be r3.Norm
	c := A_B.Norm(2) // TODO: Fix, should be r3.Norm
	abc := a + b + c
	var a_abc_A mat.Dense
	var b_abc_B mat.Dense
	var c_abc_C mat.Dense
	a_abc_A.MulElem(A, mat.NewDense(1, 3, []float64{a / abc, a / abc, a / abc}))
	b_abc_B.MulElem(B, mat.NewDense(1, 3, []float64{b / abc, b / abc, b / abc}))
	c_abc_C.MulElem(C, mat.NewDense(1, 3, []float64{c / abc, c / abc, c / abc}))
	var incenter mat.Dense
	incenter.Add(&a_abc_A, &b_abc_B)
	incenter.Add(&incenter, &c_abc_C)
	return incenter
}

func GetFacetCenterAndNormals(nodes mat.Dense, facets mat.Dense) (*mat.Dense, *mat.Dense) {
	r, c := facets.Dims()
	fmn := mat.NewDense(r, c, nil)
	fn := mat.NewDense(r, c, nil)
	for i := 0; i < r; i++ {
		facet := mat.NewDense(1, 3, facets.RawRowView(i))
		// TODO: facenodes should not be hardcoded to 3 by 3
		// Better to begin with facetnodes as array of r3.Vec
		facetnodes := mat.NewDense(3, 3, []float64{
			nodes.At(int(facet.At(i, 0)), 0), nodes.At(int(facet.At(i, 0)), 1), nodes.At(int(facet.At(i, 0)), 2),
			nodes.At(int(facet.At(i, 1)), 0), nodes.At(int(facet.At(i, 1)), 1), nodes.At(int(facet.At(i, 1)), 2),
			nodes.At(int(facet.At(i, 2)), 0), nodes.At(int(facet.At(i, 2)), 1), nodes.At(int(facet.At(i, 2)), 2),
		})
		incenter := GetTriangleIncenter(facetnodes)
		fmn.SetRow(i, incenter.RawMatrix().Data)
		facetnode0 := r3.Vec{X: facetnodes.At(0, 0), Y: facetnodes.At(0, 1), Z: facetnodes.At(0, 2)}
		facetnode1 := r3.Vec{X: facetnodes.At(1, 0), Y: facetnodes.At(1, 1), Z: facetnodes.At(1, 2)}
		facetnode2 := r3.Vec{X: facetnodes.At(2, 0), Y: facetnodes.At(2, 1), Z: facetnodes.At(2, 2)}
		vec0 := r3.Sub(facetnode1, facetnode0)
		vec1 := r3.Sub(facetnode2, facetnode1)
		vec2 := r3.Cross(vec0, vec1)
		vec2norm := r3.Norm(vec2)
		vec2 = r3.Vec{X: vec2.X / vec2norm, Y: vec2.Y / vec2norm, Z: vec2.Z / vec2norm}
		fn.SetRow(i, []float64{vec2.X, vec2.Y, vec2.Z})
	}
	return fmn, fn
}

func InInsideTriangle(A, B, C, P r3.Vec) bool {
	var v0, v1, v2 r3.Vec
	v0 = r3.Sub(C, A)
	v1 = r3.Sub(B, A)
	v2 = r3.Sub(P, A)
	var dot00, dot01, dot02, dot11, dot12 float64
	dot00 = r3.Dot(v0, v0)
	dot01 = r3.Dot(v0, v1)
	dot02 = r3.Dot(v0, v2)
	dot11 = r3.Dot(v1, v1)
	dot12 = r3.Dot(v1, v2)
	invDenom := 1 / (dot00*dot11 - dot01*dot01)
	u := (dot11*dot02 - dot01*dot12) * invDenom
	v := (dot00*dot12 - dot01*dot02) * invDenom
	return (u >= 0) && (v >= 0) && (u+v < 1)
}

func IndexOf(points kdtree.Points, point kdtree.Point) int {
	for i, v := range points {
		if v[0] == point[0] && v[1] == point[1] && v[2] == point[2] {
			return i
		}
	}
	return -1
}

func ProjectPointToLineSegment(A, B, p r3.Vec) (float64, r3.Vec) {
	A_B := r3.Sub(B, A)
	A_B2 := r3.Dot(A_B, A_B)
	var q r3.Vec
	t := 0.0
	if A_B2 == 0 {
		q = A
	} else {
		Ap := r3.Sub(p, A)
		t = r3.Dot(Ap, A_B) / A_B2
	}
	if t < 0 {
		q = A
	} else if t > 1 {
		q = B
	} else {
		q = r3.Add(A, r3.Scale(t, A_B))
	}
	return r3.Norm(r3.Sub(p, q)), q
}

func (m *TriangleMesh) IsInside(qPoints []r3.Vec) []int {
	// fc = facets centersClose()
	// fn = facets normals
	// fc, fn := GetFacetCenterAndNormals(m.Facets, m.Nodes)
	fc, _ := GetFacetCenterAndNormals(m.Facets, m.Nodes)
	fCount, _ := fc.Dims()
	fcPoints := make([]kdtree.Point, fCount)
	for i := 0; i < fCount; i++ {
		fcPoints[i] = []float64{fc.At(i, 0), fc.At(i, 1), fc.At(i, 2)}
	}
	// tm = tree model
	tm := kdtree.New(kdtree.Points(fcPoints), false)
	// nPoints = nearest points (i-th element is nearest point to i-th point in qPoints)
	nPoints := make([]kdtree.Comparable, len(qPoints))
	nDists := make([]float64, len(qPoints))
	nSigns := make([]int, len(qPoints))
	// nDirVec := make([]r3.Vec, len(qPoints))
	// nPp := make([]r3.Vec, len(qPoints))
	for i := 0; i < len(qPoints); i++ {
		qPoint := kdtree.Point{qPoints[i].X, qPoints[i].Y, qPoints[i].Z}
		nPoints[i], nDists[i] = tm.Nearest(qPoint)
		if nDists[i] > 0 {
			nSigns[i] = 1
		} else if nDists[i] < 0 {
			nSigns[i] = -1
		} else {
			nSigns[i] = 0
		}
		// Unnecessary computation (calculating the projection point)
		// TODO: Feel bad for not finding a better kdtree library that returns the index of the nearest point (or even better, for multiple points at once)
		// nIndex := IndexOf(fcPoints, nPoints[i].(kdtree.Point))
		// nDirVec[i] = r3.Vec{X: fn.At(nIndex, 0), Y: fn.At(nIndex, 1), Z: fn.At(nIndex, 2)}
		// nPp[i] = r3.Scale(nDists[i], nDirVec[i])
		// nPp[i] = r3.Sub(qPoints[i], nPp[i])

		// nodeIds := r3.Vec{X: m.Facets.At(nIndex, 0), Y: m.Facets.At(nIndex, 1), Z: m.Facets.At(nIndex, 2)}
		// cor0 := r3.Vec{X: m.Nodes.At(int(nodeIds.X), 0), Y: m.Nodes.At(int(nodeIds.X), 1), Z: m.Nodes.At(int(nodeIds.X), 2)}
		// cor1 := r3.Vec{X: m.Nodes.At(int(nodeIds.Y), 0), Y: m.Nodes.At(int(nodeIds.Y), 1), Z: m.Nodes.At(int(nodeIds.Y), 2)}
		// cor2 := r3.Vec{X: m.Nodes.At(int(nodeIds.Z), 0), Y: m.Nodes.At(int(nodeIds.Z), 1), Z: m.Nodes.At(int(nodeIds.Z), 2)}
		// cor3 := nPp[i]
		// inCheck := InInsideTriangle(cor0, cor1, cor2, cor3)
		// if !inCheck {
		// 	dist0, q0 := ProjectPointToLineSegment(cor0, cor1, cor3)
		// 	dist1, q1 := ProjectPointToLineSegment(cor1, cor2, cor3)
		// 	dist2, q2 := ProjectPointToLineSegment(cor0, cor2, cor3)
		// ...
		// }
	}
	return nSigns
}
